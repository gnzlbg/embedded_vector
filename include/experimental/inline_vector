#ifndef STD_EXPERIMENTAL_INLINE_VECTOR
#define STD_EXPERIMENTAL_INLINE_VECTOR
/// \file
///
/// Dynamically-resizable vector with inline storage.
///
/// Copyright Gonzalo Brito Gadeschi 2015
///
/// This file is released under the Boost Software License:
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//
// Some of the code has been adapted from libc++:
//
// and is annotated with "adapted from libc++" below, and is thus under the
// following license:
//
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
#include <array>
#include <cassert>
#include <cstddef>     // for size_t
#include <functional>  // for less and equal_to
#include <iterator>    // for reverse_iterator
#include <limits>      // for numeric_limits
#include <stdexcept>   // for length_error
#include <type_traits>

namespace std {
namespace experimental {

#ifndef inline_vector_DOXYGEN_INVOKED

namespace inline_vector_detail {

// std::array.data() is not constexpr in C++<17 so YOLO:
#if defined(_LIBCPP_VERSION)
#define STD_ARRAY_DATA(a) a.__elems_
#elif defined(__GLIBCXX__)
#define STD_ARRAY_DATA(a) a._M_elems
#else
#error Unknown std lib version
#endif

template <typename... Conds> struct and_ : std::true_type {};

template <typename Cond, typename... Conds>
struct and_<Cond, Conds...>
 : std::conditional<Cond::value, and_<Conds...>, std::false_type>::type {};

template <typename Target, typename... Ts>
using are_all_equal = and_<std::is_same<Ts, Target>...>;

using std::is_base_of;
using std::input_iterator_tag;

template <typename T> using uncvref_t = remove_reference_t<remove_cv_t<T>>;
template <typename T> using unref_t   = remove_reference_t<T>;

template <typename...> using void_t = void;

template <typename T>
using iterator_category_t =
 typename iterator_traits<remove_reference_t<T>>::iterator_category;

template <typename T, typename U = void> struct InputIterator : false_type {};

template <typename T>
struct InputIterator<T, void_t<iterator_category_t<T>>>
 : is_base_of<input_iterator_tag, iterator_category_t<T>> {};

static_assert(InputIterator<const int*>{}, "");

template <typename T, typename U = void> struct ForwardIterator : false_type {};

template <typename T>
struct ForwardIterator<T, void_t<iterator_category_t<T>>>
 : is_base_of<forward_iterator_tag, iterator_category_t<T>> {};

template <typename T, typename U = void> struct OutputIterator : false_type {};

template <typename T>
struct OutputIterator<T, void_t<iterator_category_t<T>>>
 : integral_constant<bool,
                     (is_base_of<forward_iterator_tag, iterator_category_t<T>>{}
                      and !is_const<T>{})
                      or (is_base_of<output_iterator_tag,
                                     iterator_category_t<T>>{})> {};

static_assert(OutputIterator<int*>{}, "");

template <typename From, typename To>
struct Convertible : is_convertible<unref_t<From>, unref_t<To>> {};

template <typename T>
struct CopyConstructible : is_copy_constructible<uncvref_t<T>> {};

#define REQUIRES_(...) typename = enable_if_t<(__VA_ARGS__)>

#define REQUIRES(...)       \
  template <int dummy = 42, \
            typename  = enable_if_t<(dummy == 43) || (__VA_ARGS__)>>

template <std::size_t N>
using smallest_size_type
 = conditional_t<(N < numeric_limits<uint8_t>::max()), uint8_t,
                 conditional_t<(N < numeric_limits<uint16_t>::max()), uint16_t,
                               conditional_t<(N < numeric_limits<uint32_t>::
                                                   max()),
                                             uint32_t,
                                             conditional_t<(N
                                                            < numeric_limits<uint64_t>::
                                                               max()),
                                                           uint64_t, size_t>>>>;

template <typename InputIt, typename OutputIt,
          REQUIRES_(InputIterator<InputIt>{} and OutputIterator<OutputIt>{})>
constexpr OutputIt move_backward(InputIt b, InputIt e, OutputIt to) {
  while (b != e) { *(--to) = move(*(--e)); }
  return to;
}

template <typename InputIt, typename OutputIt,
          REQUIRES_(InputIterator<InputIt>{} and OutputIterator<OutputIt>{})>
constexpr OutputIt move(InputIt b, InputIt e, OutputIt to) {
  for (; b != e; ++b, (void)++to) { *to = std::move(*b); }
  return to;
}

template <typename OutputIt, typename T, REQUIRES_(OutputIterator<OutputIt>{})>
constexpr OutputIt fill_n(OutputIt b, size_t n, const T& v) {
  for (; n > 0; ++b, --n) { *b = v; }
  return b;
}

template <typename T> constexpr void swap(T&& a, T&& b) {
  uncvref_t<T> tmp = std::move(a);
  a                = std::move(b);
  b                = std::move(tmp);
}

template <class ForwardIt, REQUIRES_(ForwardIterator<ForwardIt>{})>
constexpr void slow_rotate(ForwardIt first, ForwardIt n_first, ForwardIt last) {
  ForwardIt next = n_first;
  while (first != next) {
    swap(*(first++), *(next++));
    if (next == last) {
      next = n_first;
    } else if (first == n_first) {
      n_first = next;
    }
  }
}

template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
constexpr bool equal(_InputIterator1 __first1, _InputIterator1 __last1,
                     _InputIterator2 __first2, _InputIterator2 __last2,
                     _BinaryPredicate __pred) {
  for (; __first1 != __last1 && __first2 != __last2;
       ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2)) return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _Compare, class _InputIterator1, class _InputIterator2>
constexpr bool lexicographical_compare(_InputIterator1 __first1,
                                       _InputIterator1 __last1,
                                       _InputIterator2 __first2,
                                       _InputIterator2 __last2,
                                       _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2)) return true;
    if (__comp(*__first2, *__first1)) return false;
  }
  return false;
}

/// Storage for a vector of non-trivial elements
template <typename T, size_t Capacity, bool IsTrivial /* = false */>
struct storage {
  static_assert(Capacity != size_t{0}, "");

 private:
  smallest_size_type<Capacity> size_ = 0;
  aligned_storage_t<sizeof(T), alignment_of<T>::value> data_[Capacity];
  using data_t = decltype(data_);

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept {
    return reinterpret_cast<T const*>(data_);
  }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return reinterpret_cast<T*>(data_); }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...>
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    new (data() + size()) T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  // cannot be constexpr due to explicit destructor call
  void pop_back() noexcept(is_nothrow_destructible<T>{}) {
    assert(size() > 0);
    auto ptr = data() + size() - 1;
    ptr->~T();
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void unsafe_destroy(InputIt first, InputIt last) noexcept {
    for (; first != last; ++first) { first->~T(); }
  }

  /// Destroys all elements of the vector without changing its size (unsafe)
  constexpr void unsafe_destroy_all() noexcept {
    unsafe_destroy(data(), data() + size());
  }

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;

  // template <
  //  typename Value, typename... Values,
  //  typename
  //  = enable_if_t<!is_same<inline_vector_detail::uncvref_t<Value>,
  //  storage>{}>>
  // constexpr storage(Value&& v, Values&&... vs)
  //  : data_{std::forward<Value>(v), std::forward<Values>(vs)...} {
  //   static_assert(sizeof...(Values) + 1 <= Capacity, "");
  //   unsafe_set_size(sizeof...(Values) + 1);
  // }

  template <typename U, REQUIRES_(Convertible<U, T>{})>
  constexpr storage(std::initializer_list<U> il) : data_{il} {
    unsafe_set_size(il.size());
  }

  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
  ~storage() { unsafe_destroy_all(); }
};

/// Storage for a vector of trivial elements
template <typename T, size_t Capacity>  //
struct storage<T, Capacity, true> {
  static_assert(Capacity != size_t{0}, "");

 private:
  smallest_size_type<Capacity> size_ = 0;
  using data_t
   = std::conditional_t<!std::is_const<T>{}, std::array<T, Capacity>,
                        const std::array<std::remove_const_t<T>, Capacity>>;
  // alignas(T) T data_[Capacity]{};
  data_t data_{};

 public:
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return STD_ARRAY_DATA(data_); }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return STD_ARRAY_DATA(data_); }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr size_t size() const noexcept { return size_; }

  /// TODO: constrain to Constructible<T, Args...> and (MoveAssignable<T> or
  /// CopyAssignable<T>)
  /// TODO: conditionally noexcept
  template <typename... Args>  //
  constexpr void emplace_back(Args&&... args) {
    assert(size() <= Capacity);
    data_[size()] = T(forward<Args>(args)...);
    unsafe_set_size(size() + 1);
  }

  // calling pop back on an empty container is undefined
  constexpr void pop_back() noexcept {
    assert(size() > 0);
    unsafe_set_size(size() - 1);
  }

 protected:
  /// Changes the container size (unsafe)
  constexpr void unsafe_set_size(size_t new_size) noexcept { size_ = new_size; }

  template <typename InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void unsafe_destroy(InputIt, InputIt) noexcept {}

  /// Destroys all elements of the vector without changing its size (unsafe)
  static constexpr void unsafe_destroy_all() noexcept {}

 public:
  constexpr storage()               = default;
  constexpr storage(storage const&) = default;

  template <typename U, REQUIRES_(Convertible<U, T>{})>
  static constexpr std::array<std::remove_const_t<T>, Capacity> create_data(
   std::initializer_list<U> il) {
    std::array<std::remove_const_t<T>, Capacity> value{};
    for (size_t i = 0; i < il.size(); ++i) {
      STD_ARRAY_DATA(value)[i] = il.begin()[i];
    }
    return value;
  }
  template <typename U, REQUIRES_(Convertible<U, T>{})>
  constexpr storage(std::initializer_list<U> il) : data_(create_data(il)) {
    unsafe_set_size(il.size());
  }

  constexpr storage& operator=(storage const&) = default;
  constexpr storage(storage&&)                 = default;
  constexpr storage& operator=(storage&&) = default;
};

template <typename T> struct empty_storage {
  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr const T* data() const noexcept { return nullptr; }

  /// Direct access to the underlying storage
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  constexpr T* data() noexcept { return nullptr; }

  /// Number of elements in the vector
  ///
  /// Time complexity: O(1)
  /// Space complexity: O(1)
  static constexpr size_t size() noexcept { return 0; }

  /// Changes the container size (unsafe)
  static constexpr void unsafe_set_size(size_t new_size) noexcept {
    assert(new_size == size_t{0}
           && "trying to set the size of a zero-capacity vector to value != 0");
  }

  template <typename InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void unsafe_destroy(InputIt first, InputIt last) noexcept {
    assert(first == last);
  }

  /// For trivially destructible types there is nothing to do
  static constexpr void unsafe_destroy_all() noexcept {}

  template <typename... Args>  //
  static constexpr void emplace_back(Args&&...) {
    assert(false);
  }

  static constexpr void pop_back() noexcept { assert(false); }

  explicit empty_storage(size_t n) { assert(n == size_t(0)); }
  empty_storage()                     = default;
  empty_storage(empty_storage const&) = default;
  empty_storage(empty_storage&&)      = default;

  empty_storage& operator=(empty_storage const&) = default;
  empty_storage& operator=(empty_storage&&) = default;

  // empty_storage(initializer_list<T> il) { assert(il.size() == 0); }
};

template <typename T>  //
struct storage<T, 0, true> : empty_storage<T> {
  using empty_storage<T>::empty_storage;
  using empty_storage<T>::operator=;
};

template <typename T>  //
struct storage<T, 0, false> : empty_storage<T> {
  using empty_storage<T>::empty_storage;
  using empty_storage<T>::operator=;
};

}  // namespace inline_vector_detail

#endif  // inline_vector_DOXYGEN_INVOKED

/// Dynamically-resizable vector with inline storage
template <typename T, size_t Capacity>  //
struct inline_vector
 : private inline_vector_detail::storage<T, Capacity, is_trivial<T>{}> {
 private:
  using self   = inline_vector<T, Capacity>;
  using base_t = inline_vector_detail::storage<T, Capacity, is_trivial<T>{}>;

 public:
  using base_t::data;
  using base_t::size;
  using base_t::emplace_back;
  using base_t::pop_back;

 private:
  using base_t::unsafe_set_size;
  using base_t::unsafe_destroy;
  using base_t::unsafe_destroy_all;

  template <typename It>
  using InputIterator = inline_vector_detail::InputIterator<It>;

  template <typename From, typename To>
  using Convertible = inline_vector_detail::Convertible<From, To>;

  template <typename U>
  using CopyConstructible = inline_vector_detail::CopyConstructible<U>;

  template <typename U> using uncvref_t = inline_vector_detail::uncvref_t<U>;

  static_assert(is_nothrow_destructible<T>{},
                "inline_vector requires T to be nothrow destructible");

 public:
  using value_type             = T;
  using reference              = value_type&;
  using const_reference        = value_type const&;
  using iterator               = T*;
  using const_iterator         = T const*;
  using size_type              = size_t;
  using difference_type        = ptrdiff_t;
  using pointer                = T*;
  using const_pointer          = T const*;
  using reverse_iterator       = typename std::reverse_iterator<iterator>;
  using const_reverse_iterator = typename std::reverse_iterator<const_iterator>;

  /// \name Iterators
  ///@{

  constexpr iterator begin() noexcept { return data(); }
  constexpr const_iterator begin() const noexcept { return data(); }
  constexpr iterator end() noexcept { return data() + size(); }
  constexpr const_iterator end() const noexcept { return data() + size(); }

  reverse_iterator rbegin() noexcept { return reverse_iterator(end() - 1); }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end() - 1);
  }
  reverse_iterator rend() noexcept { return reverse_iterator(data() - 1); }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(data() - 1);
  }

  constexpr const_iterator cbegin() noexcept { return begin(); }
  constexpr const_iterator cbegin() const noexcept { return begin(); }
  constexpr const_iterator cend() noexcept { return end(); }
  constexpr const_iterator cend() const noexcept { return end(); }

  ///@}  // Iterators

  /// \name Construct/copy/move/destroy
  ///@{

  constexpr inline_vector() noexcept : base_t() {}

  /// Can always throw if n > capacity
  constexpr explicit inline_vector(size_type n) { insert(begin(), n); }

  /// can always throw if n > Capacity
  REQUIRES(CopyConstructible<T>{})
  constexpr inline_vector(size_type n, const T& value) {
    insert(begin(), n, value);
  }

  /// TODO:S assert distance for RandomAccessIterator (QoI)
  /// can always throw if distance(first, last) > capacity
  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr inline_vector(InputIt first, InputIt last) {
    insert(begin(), first, last);
  }

  /// can always throw if other.size() > capacity() which can only happen if M
  /// >
  /// Capacity
  template <std::size_t M, typename = enable_if_t<(Capacity != M)>>
  constexpr inline_vector(inline_vector<T, M> const& other) noexcept(
   M <= Capacity and is_nothrow_copy_constructible<T>{}
   and is_nothrow_copy_assignable<T>{}) {
    using std::begin;
    using std::end;
    insert(this->begin(), begin(other), end(other));
  }

  /// can always throw if other.size() > capacity() which can only happen if M
  /// >
  /// Capacity
  template <std::size_t M, typename = enable_if_t<(Capacity != M)>>
  constexpr inline_vector(inline_vector<T, M>&& other) noexcept(
   M <= Capacity and is_nothrow_move_constructible<T>{}
   and is_nothrow_move_assignable<T>{}) {
    move_insert(this->begin(), begin(other), end(other));
  }

  /// same capacity so can only throw if copy constructor or copy assignment can
  /// throw
  constexpr inline_vector(inline_vector const& other) noexcept(
   is_nothrow_copy_assignable<T>{} and is_nothrow_copy_constructible<T>{}) {
    using std::begin;
    using std::end;
    insert(this->begin(), begin(other), end(other));
  }

  /// same capacity so can only throw if move constructor or move assignment can
  /// throw
  constexpr inline_vector(inline_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    using std::begin;
    using std::end;
    move_insert(this->begin(), begin(other), end(other));
  }
  // can always throw if il.size() > capacity()
  // template <typename Value, typename... Values,
  //           REQUIRES_(  // Convertible<Value, value_type>{}
  //            std::is_same<uncvref_t<Value>, uncvref_t<T>>{}
  //            // and !std::is_same<uncvref_t<Value>, inline_vector<T>>{}
  //            and inline_vector_detail::are_all_equal<Value, Values...>{})>
  // constexpr inline_vector(Value&& v, Values&&... vs)
  //  : base_t(std::forward<Value>(v), std::forward<Values>(vs)...) {}

  template <typename U, REQUIRES_(Convertible<U, value_type>{})>
  constexpr inline_vector(initializer_list<U> il) : base_t(std::move(il)) {}

  // using base_t::~base_t;  // inheriting the destructor allows this type to
  // be
  //                         // trivially destructible

  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr inline_vector& operator=(inline_vector const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(other), end(other));
    return *this;
  }
  /// same capacity so can only thow if copy constructor or copy assignment
  /// throws
  ///
  /// cannot provide strong exception guarantee
  constexpr inline_vector& operator=(inline_vector&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    using std::begin;
    using std::end;
    clear();
    move_insert(this->begin(), begin(other), end(other));
    return *this;
  }

  /// TODO: conditionally noexcept
  template <std::size_t M, typename = enable_if_t<(Capacity != M)>>
  constexpr inline_vector& operator=(inline_vector<T, M> const& other) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_copy_assignable<T>{}) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(other), end(other));
    return *this;
  }
  /// TODO: conditionally noexcept
  template <std::size_t M, typename = enable_if_t<(Capacity != M)>>
  constexpr inline_vector& operator=(inline_vector<T, M>&& other) noexcept(
   is_nothrow_move_assignable<T>{} and is_nothrow_move_constructible<T>{}) {
    using std::begin;
    using std::end;
    clear();
    move_insert(this->begin(), begin(other), end(other));
    return *this;
  }

  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr void assign(InputIt first, InputIt last) {
    clear();
    insert(begin(), first, last);
  }

  REQUIRES(CopyConstructible<T>{})
  constexpr void assign(size_type n, const T& u) {
    clear();
    insert(begin(), n, u);
  }
  REQUIRES(CopyConstructible<T>{})
  constexpr void assign(initializer_list<T> const& il) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(il), end(il));
  }
  // cannot move elements out of an initializer_list
  REQUIRES(CopyConstructible<T>{})
  constexpr void assign(initializer_list<T>&& il) {
    using std::begin;
    using std::end;
    clear();
    insert(this->begin(), begin(il), end(il));
  }

///@}  // Construct/copy/move/destroy

/// \name size / capacity
///@{

#ifdef inline_vector_DOXYGEN_INVOKED
  /// Number of elements in the vector
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr size_t size() const noexcept;
#endif  // inline_vector_DOXYGEN_INVOKED

  /// Number of elements that can be held in the vector storage
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type capacity() noexcept { return Capacity; }

  /// Maximum number of elements the container is able to hold due to system or
  /// library implementation limitations.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - always
  ///
  /// Effect: none
  ///
  static constexpr size_type max_size() noexcept { return capacity(); }

#ifndef inline_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized
  void reserve(size_type n) /* inline_vector has FIXED CAPACITY */ = delete;
#endif  // inline_vector_DOXYGEN_INVOKED

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are copy-constructed from \p value.
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     copy-constructions of \p value
  ///   - if \p sz < `size()`: exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  REQUIRES(CopyConstructible<T>{})
  constexpr void resize(size_type sz, T const& value) noexcept(
   is_nothrow_copy_constructible<T>{} and is_nothrow_destructible<T>{}) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "inline_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size(), value);
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Resizes the container to contain \p sz elements. If elements need to be
  /// appended, these are move-constructed from `T{}` (or copy-constructed if
  /// `T` is not `MoveConstructible`).
  ///
  /// Complexity:
  /// - space: O(1)
  /// - time:
  ///   - if \p sz >= `size()`: exactly: (sz - `size()`)
  ///     move or copy-constructions of \p `T{}`
  ///   - if \p sz < `size()`: O(N), exactly (`size()` - sz) destructions
  ///     of values of type `T`.
  ///
  /// Exception-safety:
  /// - if an exception is thrown other than by the move constructor or the
  /// destructor of a non-CopyInsertable T there are no effects.
  /// - if sz > `capacity()` a `length_error` exception is thrown and there
  ///   are no effects.
  ///
  /// Constexpr:
  /// - if vector is constexpr, and:
  ///   - the copy-constructor of T is constexpr if (sz >= `size()`), or
  ///   - the destructor of T is constexpr if (sz < `size()`)
  ///
  /// Effect:
  /// - if sz == `size` no effects
  /// - if sz >= size, (sz - `size()`) copy-constructions of \p value and
  ///   `size()` will return \p sz on success.
  /// - if sz < size, (`size()` - sz) destructions of \p value and
  ///   `size()` will return \p sz on success.
  ///
  /// TODO: constrain: MoveInsertable and DefaultInsertable
  constexpr void resize(size_type sz) noexcept(
   is_nothrow_destructible<T>{}
   and ((is_move_constructible<T>{} and is_nothrow_move_constructible<T>{})
        or (is_copy_constructible<T>{}
            and is_nothrow_copy_constructible<T>{}))) {
    if (sz == size()) { return; }
    if (sz > size()) {
      if (sz > capacity()) {
        throw length_error(
         "inline_vector cannot be resized to a size greater than capacity");
      }
      insert(end(), sz - size());
    } else {
      erase(end() - (size() - sz), end());
    }
  }

  /// Checks whether the container is empty
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effects: none.
  constexpr bool empty() const noexcept { return size() == size_type(0); }

#ifndef inline_vector_DOXYGEN_INVOKED
  // Explicitly deleted to improve error messages since the storage of the
  // vector cannot be resized:
  void shrink_to_fit() = delete;
#endif  // inline_vector_DOXYGEN_INVOKED

  ///@}  // Size / capacity

  /// \name Element access
  ///@{

  constexpr reference operator[](size_type pos) noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr const_reference operator[](size_type pos) const noexcept {
    assert(pos < size());
    return *(begin() + pos);
  }

  constexpr reference at(size_type pos) {
    if (pos >= size()) {
      throw out_of_range("cannot access inline_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  constexpr const_reference at(size_type pos) const {
    if (pos >= size()) {
      throw out_of_range("cannot access inline_vector element at pos >= size");
    }
    return (*this)[pos];
  }

  REQUIRES(Capacity > 0)
  constexpr reference front() noexcept {
    assert(size() > 0);
    return *begin();
  }
  REQUIRES(Capacity > 0)
  constexpr const_reference front() const noexcept {
    assert(size() > 0);
    return *begin();
  }

  REQUIRES(Capacity > 0)
  constexpr reference back() noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }
  REQUIRES(Capacity > 0)
  constexpr const_reference back() const noexcept {
    assert(size() > 0);
    return *(end() - 1);
  }

///@}  // Element access

#ifdef inline_vector_DOXYGEN_INVOKED
  /// \name Data access
  ///@{

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but
  /// it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Exception-safety:
  /// - never throws (noexcept(true))
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr const T* data() const noexcept;

  /// Direct access to the underlying storage
  ///
  /// Returns an unspecified value if the capacity of the vector is zero, but
  /// it
  /// is guaranteed that in that case data() == begin() == end().
  ///
  /// In this implementation the unspecified value is `nullptr`.
  ///
  /// Complexity:
  /// - time: O(1)
  /// - space: O(1)
  ///
  /// Constexpr:
  /// - if vector is constexpr
  ///
  /// Effect: none
  ///
  constexpr T* data() noexcept;

///@}  // Data access
#endif  // inline_vector_DOXYGEN_INVOKED

/// \name Modifiers
///@{

#ifdef inline_vector_DOXYGEN_INVOKED
  template <typename... Args> void emplace_back(Args&&... args);
#endif  // inline_vector_DOXYGEN_INVOKED

  /// Push back
  ///
  /// TODO: Cannot be constexpr because of emplace_back usage of placement
  /// TODO: constrain: , CONCEPT_REQUIRES_(Constructible<T, U>{})
  ///   /// TODO: make noexcept if same condition as emplace back
  template <typename U, REQUIRES_(Convertible<U, value_type>{})>
  void push_back(U&& value) {
    emplace_back(forward<U>(value));
  }

#ifdef inline_vector_DOXYGEN_INVOKED
  /// Pop back
  ///
  void pop_back() noexcept(is_nothrow_destructible<T>{});
#endif

  template <class... Args>
  constexpr iterator emplace(const_iterator position, Args&&... args) {
    value_type a(forward<Args>(args)...);
    return move_insert(position, &a, &a + 1);
  }
  REQUIRES(CopyConstructible<T>{})
  constexpr iterator insert(const_iterator position, const_reference x) {
    return insert(position, size_type(1), x);
  }

  constexpr iterator insert(const_iterator position, value_type&& x) {
    return move_insert(position, &x, &x + 1);
  }

  REQUIRES(CopyConstructible<T>{})
  constexpr iterator insert(const_iterator position, size_type n, const T& x) {
    const auto new_size = size() + n;
    if (new_size > capacity()) throw length_error("");
    auto b = end();
    while (n != 0) {
      push_back(x);
      --n;
    }

    iterator writable_position = begin() + (position - begin());
    inline_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  template <typename SizeType, REQUIRES_(is_same<SizeType, size_type>{})>
  constexpr iterator insert(const_iterator position, SizeType n) {
    const auto new_size = size() + n;
    if (new_size > capacity()) throw length_error("");
    auto b = end();
    while (n != 0) {
      emplace_back();
      --n;
    }

    iterator writable_position = begin() + (position - begin());
    inline_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr iterator insert(const_iterator position, InputIt first,
                            InputIt last) {
    // Decided against optimization for ForwardIterator: we could compute the
    // distance and throw early if it exceeds the capacity, but that makes
    // things faster in the exceptional path, and the extra distance computation
    // makes things slower in the non-exceptional path.
    //
    // TODO: apply this optimization for RandomAccessIterator since then it has
    // ~zero-cost.
    auto b = end();
    //    try {  // if copy_constructor throws you get basic-guarantee?
    for (; first != last; ++first) { push_back(*first); }
    // } catch (...) {
    //   erase(b, end());
    //   throw;
    // }
    // we insert at the end and then just rotate:
    auto writable_position = begin() + (position - begin());
    inline_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  template <class InputIt, REQUIRES_(InputIterator<InputIt>{})>
  constexpr iterator move_insert(const_iterator position, InputIt first,
                                 InputIt last) {
    // Decided against optimization for ForwardIterator: we could compute the
    // distance and throw early if it exceeds the capacity, but that makes
    // things faster in the exceptional path, and the extra distance computation
    // makes things slower in the non-exceptional path.
    //
    // TODO: apply this optimization for RandomAccessIterator since then it has
    // ~zero-cost.
    auto b = end();
    //    try {  // if copy_constructor throws you get basic-guarantee?
    for (; first != last; ++first) { push_back(std::move(*first)); }
    // } catch (...) {
    //   erase(b, end());
    //   throw;
    // }
    // we insert at the end and then just rotate:
    auto writable_position = begin() + (position - begin());
    inline_vector_detail::slow_rotate(writable_position, b, end());
    return writable_position;
  }

  REQUIRES(CopyConstructible<T>{})
  constexpr iterator insert(const_iterator position, initializer_list<T> il) {
    using std::begin;
    using std::end;
    return insert(position, begin(il), end(il));
  }
  constexpr iterator erase(const_iterator position) {
    return erase(position, position + 1);
  }
  constexpr iterator erase(const_iterator first, const_iterator last) {
    assert(first <= last);
    iterator p = begin() + (first - begin());
    if (first != last) {
      unsafe_destroy(inline_vector_detail::move(p + (last - first), end(), p),
                     end());
      unsafe_set_size(size() - (last - first));
    }

    return p;
  }

  constexpr void clear() noexcept(is_nothrow_destructible<T>{}) {
    unsafe_destroy_all();
    unsafe_set_size(0);
  }

  template <typename Other>
  constexpr enable_if_t<is_same<uncvref_t<Other>, inline_vector>{}
                        and Capacity == 0>
   swap(Other&) noexcept(true) {}

  // TODO: this is rough use std::swap
  template <typename Other>
  constexpr enable_if_t<is_same<uncvref_t<Other>, inline_vector>{}
                        and Capacity != 0>
   swap(Other& other) noexcept(
    noexcept(inline_vector_detail::swap(declval<T&>(), declval<T&>()))) {
    using inline_vector_detail::swap;
    inline_vector tmp = std::move(other);
    other             = std::move(*this);
    (*this)           = std::move(tmp);
  }

  /// TODO: swap for different capacities

  ///@}  // Modifiers
};

template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator==(const inline_vector<T, C0>& a,
                          const inline_vector<T, C1>& b) {
  return inline_vector_detail::equal(a.begin(), a.end(), b.begin(), b.end(),
                                     equal_to<>{});
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator!=(const inline_vector<T, C0>& a,
                          const inline_vector<T, C1>& b) {
  return !(a == b);
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator<(const inline_vector<T, C0>& a,
                         const inline_vector<T, C1>& b) {
  return inline_vector_detail::lexicographical_compare(
   a.begin(), a.end(), b.begin(), b.end(), less<>{});
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator<=(const inline_vector<T, C0>& a,
                          const inline_vector<T, C1>& b) {
  return !(a > b);
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator>(const inline_vector<T, C0>& a,
                         const inline_vector<T, C1>& b) {
  return b < a;
}
template <typename T, std::size_t C0, std::size_t C1>
constexpr bool operator>=(const inline_vector<T, C0>& a,
                          const inline_vector<T, C1>& b) {
  return !(a < b);
}

}  // namespace experimental
}  // namespace std

#undef REQUIRES_
#undef REQUIRES

#endif  // STD_EXPERIMENTAL_INLINE_VECTOR
